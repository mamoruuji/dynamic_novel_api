package main

import (
	"context"
	"database/sql"
	"log"
	"net/http"

	"github.com/amomon/dynamic_novel_api/db/models"
	_ "github.com/lib/pq"

	// . "github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/boil"

	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	dynamicv1 "github.com/amomon/dynamic_novel_api/gen/proto/dynamic/v1"        // generated by protoc-gen-go
	"github.com/amomon/dynamic_novel_api/gen/proto/dynamic/v1/dynamicv1connect" // generated by protoc-gen-connect-go
	"github.com/bufbuild/connect-go"
	// "google.golang.org/grpc"
)

type dynamicServer struct {
	dynamicv1connect.DynamicServiceHandler
}

func (s *dynamicServer) GetDynamics(ctx context.Context, _ *connect.Request[dynamicv1.GetDynamicsRequest]) (*connect.Response[dynamicv1.GetDynamicsResponse], error) {
	dynamics, err := models.Dynamics().All(ctx, boil.GetContextDB())
	if err != nil {
		log.Printf("failed to get dynamics: %v", err)
		return nil, err
	}

	var pbDynamics []*dynamicv1.DynamicData
	for _, d := range dynamics {
		dynamicID := int32(d.DynamicID)
		pbDynamic := &dynamicv1.DynamicData{
			DynamicId: dynamicID,
			Title:     d.Title,
			Overview:  d.Overview,
			UserId:    d.UserID,
			Published: d.Published,
		}
		pbDynamics = append(pbDynamics, pbDynamic)
	}

	res := connect.NewResponse(&dynamicv1.GetDynamicsResponse{
		Dynamics: pbDynamics,
	})

	return res, nil
}

func (s *dynamicServer) AddDynamic(ctx context.Context, req *connect.Request[dynamicv1.AddDynamicRequest]) (*connect.Response[dynamicv1.AddDynamicResponse], error) {
	d := models.Dynamic{
		Title:     req.Msg.Title,
		UserID:    req.Msg.UserId,
		Published: false,
	}
	err := d.Insert(ctx, boil.GetContextDB(), boil.Infer())
	if err != nil {
		log.Printf("failed to add dynamic: %v", err)
		return nil, err
	}

	dynamicID := int32(d.DynamicID)
	res := connect.NewResponse(&dynamicv1.AddDynamicResponse{
		DynamicId: dynamicID,
	})

	return res, nil
}

func (s *dynamicServer) DeleteDynamic(ctx context.Context, req *connect.Request[dynamicv1.DeleteDynamicRequest]) (*connect.Response[dynamicv1.DeleteDynamicResponse], error) {
	dynamicID := int(req.Msg.DynamicId)
	d := models.Dynamic{
		DynamicID: dynamicID,
	}

	_, err := d.Delete(ctx, boil.GetContextDB())
	if err != nil {
		log.Printf("failed to delete dynamic: %v", err)
		return nil, err
	}

	return connect.NewResponse(&dynamicv1.DeleteDynamicResponse{}), nil
}

func (s *dynamicServer) UpdateDynamicStatus(ctx context.Context, req *connect.Request[dynamicv1.UpdateDynamicStatusRequest]) (*connect.Response[dynamicv1.UpdateDynamicStatusResponse], error) {
	dynamicID := int(req.Msg.DynamicId)
	d := models.Dynamic{
		DynamicID: dynamicID,
	}

	d.Title = req.Msg.Title
	d.Overview = req.Msg.Overview
	d.Published = req.Msg.Published
	_, err := d.Update(ctx, boil.GetContextDB(), boil.Infer())
	if err != nil {
		log.Printf("failed to update dynamic status: %v", err)
		return nil, err
	}

	return connect.NewResponse(&dynamicv1.UpdateDynamicStatusResponse{}), nil
}

func server() http.Handler {
	mux := http.NewServeMux()
	path, handler := dynamicv1connect.NewDynamicServiceHandler(&dynamicServer{})
	mux.Handle(path, handler)
	return mux
}

func main() {
	db, err := sql.Open("postgres", "host=db port=5432 user=postgres password=pass dbname=dynamic_novel sslmode=disable")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		log.Fatal(err)
	}

	boil.SetDB(db)

	mux := server()

	err = http.ListenAndServe(
		":8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(mux, &http2.Server{}),
	)
	if err != nil {
		log.Fatal(err)
	}

}
