package server

import (
	"context"
	"log"

	. "github.com/mamoruuji/dynamic_novel_api/config"

	"github.com/bufbuild/connect-go"
	dynamicv1 "github.com/mamoruuji/dynamic_novel_api/gen/proto/dynamic/v1"
	"github.com/mamoruuji/dynamic_novel_api/gen/proto/dynamic/v1/dynamicv1connect" // generated by protoc-gen-connect-go

	. "github.com/mamoruuji/dynamic_novel_api/db/models"
	"github.com/volatiletech/sqlboiler/v4/boil"
	. "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type imageServer struct {
	dynamicv1connect.ImageServiceHandler
	db boil.ContextExecutor
}

func NewImageServer() *imageServer {
	return &imageServer{
		db: GetDB(),
	}

}
func (s *imageServer) ListUserImages(
	ctx context.Context,
	req *connect.Request[dynamicv1.ListUserImagesRequest],
) (*connect.Response[dynamicv1.ListUserImagesResponse], error) {
	modifiers := []QueryMod{
		Load(FolderRels.Images),
		Load(Rels(FolderRels.Images, ImageRels.TypeImage)),
		FolderWhere.UserID.EQ(req.Msg.UserId),
		OrderBy(FolderColumns.ID),
	}
	rootFolders, err := Folders(modifiers...).All(ctx, s.db)

	if err != nil {
		log.Printf("failed to get images: %v", err)
		return nil, err
	}
	// fmt.Println(rootFolders)
	// フォルダIDをキーにしたマップを作成
	// folderMap := GetFoldersMap(rootFolders)

	// 親IDが0（ルート）のフォルダから階層構造を構築
	// folderTree := BuildTree(folderMap, 0)
	// Dump(folderTree)
	// fmt.Println(folderTree)
	// for _, folder := range folderTree {
	// 	Dump(folder.Images)
	// }

	modifiers = []QueryMod{
		Load(ImageRels.TypeImage),
		ImageWhere.UserID.EQ(req.Msg.UserId),
		ImageWhere.FolderID.IsNull(),
		OrderBy(ImageColumns.ID),
	}
	rootImages, err := Images(modifiers...).All(ctx, s.db)

	if err != nil {
		log.Printf("failed to get images: %v", err)
		return nil, err
	}
	// fmt.Println(rootImages)

	var folders []*dynamicv1.FolderData
	for _, root := range rootFolders {
		folders = append(folders, convertFolder(root))
	}
	pbImages := SetImagesData(rootImages)

	res := connect.NewResponse(&dynamicv1.ListUserImagesResponse{
		Folders: folders,
		Images:  pbImages,
	})

	return res, nil
}

// // GetFoldersMap creates a map of folder_id to Folder
// func GetFoldersMap(folders []*models.Folder) map[int]*models.Folder {
// 	folderMap := make(map[int]*models.Folder)
// 	for _, folder := range folders {
// 		folderMap[int(folder.FolderID)] = folder
// 	}
// 	return folderMap
// }

// // BuildTree recursively builds the folder tree
// func BuildTree(folderMap map[int]*models.Folder, parentID int) []*dynamicv1.FolderData {
// 	var result []*dynamicv1.FolderData
// 	for _, folder := range folderMap {
// 		if int(folder.ParentID.Int32) == parentID {
// 			pbImages := SetImagesData(folder.R.Images)
// 			node := &dynamicv1.FolderData{
// 				FolderId: folder.FolderID,
// 				Name:     folder.Name,
// 				UserId:   folder.UserID,
// 				ParentId: folder.FolderID,
// 				Children: BuildTree(folderMap, int(folder.FolderID)),
// 				Images:   pbImages,
// 			}
// 			result = append(result, node)
// 		}
// 	}
// 	return result
// }

func convertFolder(f *Folder) *dynamicv1.FolderData {
	var children []*dynamicv1.FolderData
	for _, child := range f.R.ParentFolders {
		children = append(children, convertFolder(child))
	}

	var pbImages []*dynamicv1.ImageData
	for _, image := range f.R.Images {
		pbImage := SetImageData(image)
		pbImages = append(pbImages, pbImage)
	}

	return &dynamicv1.FolderData{
		FolderId: f.ID,
		Name:     f.Name,
		UserId:   f.UserID,
		ParentId: f.ParentID.Int32,
		Children: children,
		Images:   pbImages,
	}
}
